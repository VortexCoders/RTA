import asyncio
import logging
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime, timedelta
import json
from sqlalchemy.orm import Session
from app.core.database import get_db, SessionLocal
from app.models.camera import Camera

# Configure logging for alerts
logger = logging.getLogger(__name__)

# Cache for recent alerts to prevent spam (location -> last alert time)
_alert_cache = {}
ALERT_COOLDOWN_MINUTES = 5

# Animal classification for different alert types
DANGEROUS_ANIMALS = {
    # Animals that require civilian + official alerts
    0: {"nepali": "рд╣рд╛рддреНрддреА", "english": "elephant", "type": "dangerous"}, 
    1: {"nepali": "рдЪрд┐рддреБрд╡рд╛", "english": "leopard", "type": "dangerous"},
    2: {"nepali": "рдЧреИрдВрдбрд╛", "english": "rhino", "type": "dangerous"},
    3: {"nepali": "рдмрд╛рдШ", "english": "tiger", "type": "dangerous"},
}

ENDANGERED_ANIMALS = {
    # Animals that require only official alerts
    4: {"nepali": "рд░рд╛рддреЛ рдкрд╛рдгреНрдбрд╛", "english": "red_panda", "type": "endangered"},
}

# Combine all animals for lookup
ALL_ANIMALS = {**DANGEROUS_ANIMALS, **ENDANGERED_ANIMALS}

async def send_alert_message(camera_id: str, alert_data: Dict[str, Any], video_bytes: bytes) -> None:
    """
    рдиреЗрдкрд╛рд▓реАрдорд╛ рдЕрд▓рд░реНрдЯ рд╕рдиреНрджреЗрд╢ рдкрдард╛рдЙрдиреЗ рдлрдВрдХреНрд╢рди - рдореБрдЦреНрдп рдПрдиреНрдЯреНрд░реА рдкреЛрдЗрдиреНрдЯ
    
    Args:
        camera_id (str): рдХреНрдпрд╛рдореЗрд░рд╛рдХреЛ рдЯреЛрдХрди/рдЖрдИрдбреА
        alert_data (Dict[str, Any]): рдкрддреНрддрд╛ рд▓рдЧрд╛рдЗрдПрдХрд╛ рдЬрдирд╛рд╡рд░рд╣рд░реВрдХреЛ рдЬрд╛рдирдХрд╛рд░реА
        video_bytes (bytes): 10-рд╕реЗрдХреЗрдиреНрдбрдХреЛ рднрд┐рдбрд┐рдпреЛ рдХреНрд▓рд┐рдк
    """
    try:
        # Get camera information from database
        db = SessionLocal()
        try:
            camera = db.query(Camera).filter(Camera.camera_token == camera_id).first()
            if not camera:
                logger.error(f"тЭМ рдХреНрдпрд╛рдореЗрд░рд╛ рдлреЗрд▓рд╛ рдкрд░реЗрди: {camera_id}")
                return
        finally:
            db.close()
        
        timestamp = datetime.now()
        location = camera.location or "рдЕрдЬреНрдЮрд╛рдд рд╕реНрдерд╛рди"
        
        # Extract detection information
        detections = alert_data.get('detections', [])
        highest_confidence = alert_data.get('highest_confidence', 0.0)
        
        # Filter detections and categorize animals
        dangerous_detections = []
        endangered_detections = []
        
        for detection in detections:
            class_id = detection.get('class_id', -1)
            confidence = detection.get('confidence', 0.0)
            
            if class_id in DANGEROUS_ANIMALS and confidence >= 0.50:
                dangerous_detections.append({
                    **detection,
                    'animal_info': DANGEROUS_ANIMALS[class_id]
                })
            elif class_id in ENDANGERED_ANIMALS and confidence >= 0.50:
                endangered_detections.append({
                    **detection,
                    'animal_info': ENDANGERED_ANIMALS[class_id]
                })
        
        # Log alert in Nepali
        total_animals = len(dangerous_detections) + len(endangered_detections)
        logger.info(f"ЁЯЪи рдЕрд▓рд░реНрдЯ: {location} рдорд╛ {total_animals} рд╡рдЯрд╛ рдЬрдирд╛рд╡рд░ рднреЗрдЯрд┐рдП "
                   f"рд╕рдордп: {timestamp} (рдЕрдзрд┐рдХрддрдо рд╡рд┐рд╢реНрд╡рд╕рдиреАрдпрддрд╛: {highest_confidence:.2f})")
        
        # Print alert summary in Nepali
        print(f"\nЁЯЪи рд╕реБрд░рдХреНрд╖рд╛ рдЕрд▓рд░реНрдЯ - рд╕реНрдерд╛рди: {location}")
        print(f"ЁЯУЕ рд╕рдордп: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ЁЯОп рдкрддреНрддрд╛ рд▓рдЧрд╛рдЗрдПрдХрд╛ рдЬрдирд╛рд╡рд░рд╣рд░реВ: {total_animals} рд╡рдЯрд╛")
        
        # Process dangerous animals (civilian + official alerts)
        if dangerous_detections:
            await _process_dangerous_animal_alerts(camera, dangerous_detections, video_bytes, timestamp)
        
        # Process endangered animals (official alerts only)
        if endangered_detections:
            await _process_endangered_animal_alerts(camera, endangered_detections, video_bytes, timestamp)
        
        print(f"ЁЯУ╣ рднрд┐рдбрд┐рдпреЛ рдХреНрд▓рд┐рдк рд╕рд╛рдЗрдЬ: {len(video_bytes) / 1024 / 1024:.2f} MB")
        print("-" * 50)
        
    except Exception as e:
        logger.error(f"тЭМ рдЕрд▓рд░реНрдЯ рдкрдард╛рдЙрди рдЕрд╕рдлрд▓ рднрдпреЛ camera {camera_id}: {e}")
        print(f"тЭМ рдЕрд▓рд░реНрдЯ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рддреНрд░реБрдЯрд┐: {e}")

async def _process_dangerous_animal_alerts(camera: Camera, detections: List[Dict], video_bytes: bytes, timestamp: datetime) -> None:
    """рдЦрддрд░рдирд╛рдХ рдЬрдирд╛рд╡рд░рд╣рд░реВрдХреЛ рд▓рд╛рдЧрд┐ рдирд╛рдЧрд░рд┐рдХ рд░ рдЕрдзрд┐рдХрд╛рд░реАрд╣рд░реВрд▓рд╛рдИ рдЕрд▓рд░реНрдЯ рдкрдард╛рдЙрдиреЗ"""
    location = camera.location or "рдЕрдЬреНрдЮрд╛рдд рд╕реНрдерд╛рди"
    
    # Check if we can send civilian alerts (respect cooldown)
    can_alert_civilians = _can_send_civilian_alert(location, timestamp)
    
    for detection in detections:
        animal_info = detection['animal_info']
        confidence = detection['confidence']
        animal_name = animal_info['nepali']
        
        print(f"тЪая╕П рдЦрддрд░рдирд╛рдХ рдЬрдирд╛рд╡рд░: {animal_name} (рд╡рд┐рд╢реНрд╡рд╕рдиреАрдпрддрд╛: {confidence:.2f})")
        
        # Always alert officials for dangerous animals
        await _send_official_alert(camera, animal_info, confidence, video_bytes, timestamp)
        
        # Alert civilians if cooldown period has passed
        if can_alert_civilians:
            await _send_civilian_alert(camera, animal_info, confidence, video_bytes, timestamp)
            _update_alert_cache(location, timestamp)

async def _process_endangered_animal_alerts(camera: Camera, detections: List[Dict], video_bytes: bytes, timestamp: datetime) -> None:
    """рд▓реЛрдкреЛрдиреНрдореБрдЦ рдЬрдирд╛рд╡рд░рд╣рд░реВрдХреЛ рд▓рд╛рдЧрд┐ рдХреЗрд╡рд▓ рдЕрдзрд┐рдХрд╛рд░реАрд╣рд░реВрд▓рд╛рдИ рдЕрд▓рд░реНрдЯ рдкрдард╛рдЙрдиреЗ"""
    location = camera.location or "рдЕрдЬреНрдЮрд╛рдд рд╕реНрдерд╛рди"
    
    # Check if we can send official alerts (respect cooldown for same location)
    can_alert_officials = _can_send_official_alert(location, timestamp)
    
    for detection in detections:
        animal_info = detection['animal_info']
        confidence = detection['confidence']
        animal_name = animal_info['nepali']
        
        print(f"ЁЯФ┤ рд▓реЛрдкреЛрдиреНрдореБрдЦ рдЬрдирд╛рд╡рд░: {animal_name} (рд╡рд┐рд╢реНрд╡рд╕рдиреАрдпрддрд╛: {confidence:.2f})")
        
        # Alert officials if cooldown allows
        if can_alert_officials:
            await _send_official_alert(camera, animal_info, confidence, video_bytes, timestamp)
            _update_official_alert_cache(location, timestamp)

def _can_send_civilian_alert(location: str, current_time: datetime) -> bool:
    """рдирд╛рдЧрд░рд┐рдХрд╣рд░реВрд▓рд╛рдИ рдЕрд▓рд░реНрдЯ рдкрдард╛рдЙрди рдорд┐рд▓реНрдЫ рдХрд┐ рднрдиреЗрд░ рдЬрд╛рдБрдЪ рдЧрд░реНрдиреЗ"""
    cache_key = f"civilian_{location}"
    if cache_key in _alert_cache:
        last_alert = _alert_cache[cache_key]
        if current_time - last_alert < timedelta(minutes=ALERT_COOLDOWN_MINUTES):
            return False
    return True

def _can_send_official_alert(location: str, current_time: datetime) -> bool:
    """рдЕрдзрд┐рдХрд╛рд░реАрд╣рд░реВрд▓рд╛рдИ рдЕрд▓рд░реНрдЯ рдкрдард╛рдЙрди рдорд┐рд▓реНрдЫ рдХрд┐ рднрдиреЗрд░ рдЬрд╛рдБрдЪ рдЧрд░реНрдиреЗ"""
    cache_key = f"official_{location}"
    if cache_key in _alert_cache:
        last_alert = _alert_cache[cache_key]
        if current_time - last_alert < timedelta(minutes=ALERT_COOLDOWN_MINUTES):
            return False
    return True

def _update_alert_cache(location: str, timestamp: datetime) -> None:
    """рдирд╛рдЧрд░рд┐рдХ рдЕрд▓рд░реНрдЯ рдХреНрдпрд╛рд╕ рдЕрдкрдбреЗрдЯ рдЧрд░реНрдиреЗ"""
    _alert_cache[f"civilian_{location}"] = timestamp

def _update_official_alert_cache(location: str, timestamp: datetime) -> None:
    """рдЕрдзрд┐рдХрд╛рд░реА рдЕрд▓рд░реНрдЯ рдХреНрдпрд╛рд╕ рдЕрдкрдбреЗрдЯ рдЧрд░реНрдиреЗ"""
    _alert_cache[f"official_{location}"] = timestamp

async def _send_civilian_alert(camera: Camera, animal_info: Dict, confidence: float, video_bytes: bytes, timestamp: datetime) -> None:
    """рдирд╛рдЧрд░рд┐рдХрд╣рд░реВрд▓рд╛рдИ рдЕрд▓рд░реНрдЯ рдкрдард╛рдЙрдиреЗ"""
    location = camera.location or "рдЕрдЬреНрдЮрд╛рдд рд╕реНрдерд╛рди"
    animal_name = animal_info['nepali']
    animal_type = "рдЦрддрд░рдирд╛рдХ" if animal_info['type'] == 'dangerous' else "рд▓реЛрдкреЛрдиреНрдореБрдЦ"
    
    # Voice message template in Nepali
    voice_message = f"рдпрд╕ рдХреНрд╖реЗрддреНрд░рдорд╛, рд╣рд╛рдореАрд▓реЗ рдПрдХ {animal_type} {animal_name} рднреЗрдЯреНрдпреМрдВ, рд╣рд╛рдореАрд▓реЗ рд╡реНрд╣рд╛рдЯреНрд╕рдПрдкрдорд╛ рднрд┐рдбрд┐рдпреЛ рд░ рд╡рд┐рд╡рд░рдгрд╣рд░реВ рдкрдард╛рдПрдХрд╛ рдЫреМрдВред"
    
    # WhatsApp message template in Nepali
    whatsapp_message = f"""
ЁЯЪи рд╕реБрд░рдХреНрд╖рд╛ рдЕрд▓рд░реНрдЯ ЁЯЪи

ЁЯУЕ рд╕рдордп: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}
ЁЯР╛ рдЬрдирд╛рд╡рд░: {animal_name}
ЁЯУК рд╡рд┐рд╢реНрд╡рд╕рдиреАрдпрддрд╛: {confidence:.2f}
ЁЯУН рд╕реНрдерд╛рди: {location}

тЪая╕П рд╕рд╛рд╡рдзрд╛рди рд░рд╣рдиреБрд╣реЛрд╕реН! рдпреЛ рдХреНрд╖реЗрддреНрд░рдорд╛ {animal_type} рдЬрдирд╛рд╡рд░ рджреЗрдЦрд┐рдПрдХреЛ рдЫред

ЁЯОе рднрд┐рдбрд┐рдпреЛ рдкреНрд░рдорд╛рдг рд╕рдВрд▓рдЧреНрди рдЫред
"""
    
    print(f"ЁЯУв рдирд╛рдЧрд░рд┐рдХ рдЕрд▓рд░реНрдЯ рддрдпрд╛рд░: {location}")
    print(f"ЁЯФК рднреНрд╡рд╛рдЗрд╕ рд╕рдиреНрджреЗрд╢: {voice_message}")
    
    # Store alert data for external processing
    alert_payload = {
        'type': 'civilian',
        'camera': {
            'id': camera.id,
            'name': camera.name,
            'location': camera.location,
            'phone_number': camera.phone_number,
            'camera_token': camera.camera_token
        },
        'animal_info': animal_info,
        'confidence': confidence,
        'timestamp': timestamp.isoformat(),
        'voice_message_nepali': voice_message,
        'whatsapp_message_nepali': whatsapp_message,
        'video_bytes': video_bytes
    }
    
    # Save to processing queue or call external handler
    await _queue_civilian_alert(alert_payload)

async def _send_official_alert(camera: Camera, animal_info: Dict, confidence: float, video_bytes: bytes, timestamp: datetime) -> None:
    """рдЕрдзрд┐рдХрд╛рд░реАрд╣рд░реВрд▓рд╛рдИ рдЕрд▓рд░реНрдЯ рдкрдард╛рдЙрдиреЗ"""
    location = camera.location or "рдЕрдЬреНрдЮрд╛рдд рд╕реНрдерд╛рди"
    animal_name = animal_info['nepali']
    animal_type = "рдЦрддрд░рдирд╛рдХ" if animal_info['type'] == 'dangerous' else "рд▓реЛрдкреЛрдиреНрдореБрдЦ"
    
    
    # Official alert message in Nepali
    official_message = f"""
ЁЯЪи рдЖрдзрд┐рдХрд╛рд░рд┐рдХ рд╡рдиреНрдпрдЬрдиреНрддреБ рдЕрд▓рд░реНрдЯ ЁЯЪи

ЁЯУЕ рдкрддреНрддрд╛ рд▓рдЧрд╛рдПрдХреЛ рд╕рдордп: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}
ЁЯР╛ рдЬрдирд╛рд╡рд░рдХреЛ рдирд╛рдо: {animal_name}
ЁЯУК рдкрд╣рд┐рдЪрд╛рди рд╡рд┐рд╢реНрд╡рд╕рдиреАрдпрддрд╛: {confidence:.2f}
ЁЯУН рд╕реНрдерд╛рди: {location}
ЁЯПа рдХреНрдпрд╛рдореЗрд░рд╛: {camera.name}

ЁЯУЮ рд╕рдореНрдкрд░реНрдХ рдирдореНрдмрд░: {camera.phone_number or 'рдЙрдкрд▓рдмреНрдз рдЫреИрди'}

ЁЯОе рднрд┐рдбрд┐рдпреЛ рдкреНрд░рдорд╛рдг рд╕рдВрд▓рдЧреНрди рдЫред

рддрддреНрдХрд╛рд▓ рдХрд╛рд░реНрд░рд╡рд╛рдИ рдЖрд╡рд╢реНрдпрдХ рдЫред
"""
    
    print(f"ЁЯПЫя╕П рдЕрдзрд┐рдХрд╛рд░реА рдЕрд▓рд░реНрдЯ рддрдпрд╛рд░: {location}")
    
    # Store alert data for external processing
    alert_payload = {
        'type': 'official',
        'camera': {
            'id': camera.id,
            'name': camera.name,
            'location': camera.location,
            'phone_number': camera.phone_number,
            'camera_token': camera.camera_token
        },
        'animal_info': animal_info,
        'confidence': confidence,
        'timestamp': timestamp.isoformat(),
        'official_message_nepali': official_message,
        'video_bytes': video_bytes
    }
    
    # Save to processing queue or call external handler
    await _queue_official_alert(alert_payload)

async def _queue_civilian_alert(alert_payload: Dict[str, Any]) -> None:
    """рдирд╛рдЧрд░рд┐рдХ рдЕрд▓рд░реНрдЯ queue рдорд╛ рд░рд╛рдЦреНрдиреЗ"""
    # TODO: Implement actual queuing mechanism or direct API call
    logger.info(f"я┐╜ рдирд╛рдЧрд░рд┐рдХ рдЕрд▓рд░реНрдЯ queue рдЧрд░рд┐рдпреЛ: {alert_payload['camera']['location']}")
    
    # Save evidence video
    await _save_evidence_video(alert_payload['camera']['camera_token'], alert_payload, alert_payload['video_bytes'])

async def _queue_official_alert(alert_payload: Dict[str, Any]) -> None:
    """рдЕрдзрд┐рдХрд╛рд░реА рдЕрд▓рд░реНрдЯ queue рдорд╛ рд░рд╛рдЦреНрдиреЗ"""
    # TODO: Implement actual queuing mechanism or direct API call
    logger.info(f"ЁЯПЫя╕П рдЕрдзрд┐рдХрд╛рд░реА рдЕрд▓рд░реНрдЯ queue рдЧрд░рд┐рдпреЛ: {alert_payload['camera']['location']}")
    
    # Save evidence video
    await _save_evidence_video(alert_payload['camera']['camera_token'], alert_payload, alert_payload['video_bytes'])

async def _save_evidence_video(camera_token: str, alert_data: Dict[str, Any], video_bytes: bytes) -> None:
    """рдкреНрд░рдорд╛рдг рднрд┐рдбрд┐рдпреЛ рд╕реЗрдн рдЧрд░реНрдиреЗ"""
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        animal_name = alert_data['animal_info']['english']
        alert_type = alert_data['type']
        
        filename = f"alert_{alert_type}_{camera_token}_{animal_name}_{timestamp}.mp4"
        filepath = f"recordings/{filename}"
        
        # Save video file
        with open(filepath, 'wb') as f:
            f.write(video_bytes)
        
        logger.info(f"ЁЯТ╛ рдкреНрд░рдорд╛рдг рднрд┐рдбрд┐рдпреЛ рд╕реЗрдн рднрдпреЛ: {filepath}")
        
    except Exception as e:
        logger.error(f"тЭМ рдкреНрд░рдорд╛рдг рднрд┐рдбрд┐рдпреЛ рд╕реЗрдн рдЧрд░реНрди рдЕрд╕рдлрд▓: {e}")

def format_detection_summary(detections: List[Tuple]) -> Dict[str, Any]:
    """
    рдкрддреНрддрд╛ рд▓рдЧрд╛рдЗрдПрдХрд╛ рдЬрдирд╛рд╡рд░рд╣рд░реВрдХреЛ рдЬрд╛рдирдХрд╛рд░реА рдлрд░реНрдореНрдпрд╛рдЯ рдЧрд░реНрдиреЗ
    
    Args:
        detections: List of (bbox, class_id, confidence) tuples
        
    Returns:
        Dict containing formatted detection data
    """
    if not detections:
        return {
            'detections': [],
            'detected_classes': [],
            'highest_confidence': 0.0,
            'detection_count': 0
        }
    
    formatted_detections = []
    detected_classes = set()
    confidences = []
    
    for bbox, class_id, confidence in detections:
        class_id = int(class_id)
        
        # Get animal info if available
        animal_info = ALL_ANIMALS.get(class_id, {
            "nepali": f"рдЕрдЬреНрдЮрд╛рдд рдЬрдирд╛рд╡рд░ {class_id}",
            "english": f"unknown_animal_{class_id}",
            "type": "unknown"
        })
        
        formatted_detections.append({
            'bbox': bbox.tolist() if hasattr(bbox, 'tolist') else list(bbox),
            'class_id': class_id,
            'class_name': animal_info['english'],
            'class_name_nepali': animal_info['nepali'],
            'animal_type': animal_info['type'],
            'confidence': float(confidence)
        })
        
        detected_classes.add(animal_info['nepali'])
        confidences.append(float(confidence))
    
    return {
        'detections': formatted_detections,
        'detected_classes': list(detected_classes),
        'highest_confidence': max(confidences) if confidences else 0.0,
        'detection_count': len(formatted_detections)
    }
